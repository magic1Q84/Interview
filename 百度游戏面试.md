## 1、C++内存管理
一般分为五个部分  
### 1.1栈区
由系统自动分配和释放，一般存储函数名、局部变量的名等。其操作方式类似于数据结构中的栈。
### 1.2堆区
堆区一般由程序员来分配和释放，若不释放也会在程序结束后被OS收回。其分配方式类似于链表。
### 1.3全局/静态存储区
这一部分用于存储全局变量和局部静态变量，程序结束时系统自动释放。
### 1.4常量取区
这部分存放了常量，无法被更改，程序结束时系统自动释放。
### 1.5代码区
该区存放了程序的二进制代码

## 2、智能指针
C++最大的问题就是容易发生内存泄漏  
动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针  
为了安全简便的使用指针C++11中加入了智能指针，智能指针的行为和常规指针类似，但一个重要的区别是它会自动释放所指向的对象。  
标准库根据底层管理指针的方法提供了两种智能指针，share_ptr和unique_ptr，sgare_ptr允许多个指针指向同一对象，而unique_ptr则独占指向对象，标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。  

## 3、C++中override的作用
在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：  
一虚：基类中，成员函数声明为虚拟的 (virtual)  
二容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容  
四同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同  
如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错  
C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。  

    class Base {
    public:
        virtual void mf1() const;
        virtual void mf2(int x);
        virtual void mf3() &;
        void mf4() const;    // is not declared virtual in Base
    };
    在派生类中重写如下：
    class Derived: public Base {
    public:
        virtual void mf1() const override;  // adding "virtual" is OK, but not necessary
        virtual void mf2(int x) override;
        void mf3() & override;
        void mf4() const override; 
    }; 
    
简单来说就是就是加上override来明确表明这是重写基类，以便于编译器检查。  
一般来说可以直接用overrid来代替virtual  

## 4、C++虚函数
这个我其实还没用过，这是用来实现多态的，C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。（是不是有点泛型的味道）
就是继承出来的函数和父函数可以有同一个函数名的函数，在调用的时候程序会判断（通过虚函数表）到底是哪个函数被用到

## 5、C++程序的编译过程
分为四个步骤
### 5.1预处理
预处理用于将所有的#include头文件以及宏定义还有特殊符号替换成其真正的内容。
### 5.2编译
将经过预处理的文件转换成汇编代码
### 5.3汇编
将编译完成的汇编代码进一步处理转换为机器码
### 5.4链接
将多个目标文件及库文件链接为最终可用的文件

## TCP和UDP的区别







